<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>面向对象设计模式</title>
    <url>/2019/10/22/object-sjms/</url>
    <content><![CDATA[<h1 id="设计模式的概念"><a href="#设计模式的概念" class="headerlink" title="设计模式的概念"></a>设计模式的概念</h1><h2 id="架构模式"><a href="#架构模式" class="headerlink" title="架构模式"></a><strong>架构模式</strong></h2><p>软件设计中的高层决策，例如C/S结构。架构模式反映了开发软件系统过程中所做的基本设计决策。</p>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a><strong>设计模式</strong></h2><p>主要关注软件系统的设计，与具体的实现语言无关。</p>
<h2 id="惯用法"><a href="#惯用法" class="headerlink" title="惯用法"></a><strong>惯用法</strong></h2><p>是最底层的模式，关注软件系统的设计与实现，实现时通过某种特定的程序设计语言来描述构件与构件之间的关系。每种编程语言都有它自己特定的模式，即语言的惯用法。例如引用-计数就是C++语言中的一种惯用法。</p>
<h1 id="设计模式分类"><a href="#设计模式分类" class="headerlink" title="设计模式分类"></a>设计模式分类</h1><p><img src="/images/object_sjms.png" alt=""></p>
<h3 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a><strong>创建型模式</strong></h3><ul>
<li>抽象工厂模式（Abstract Factory）：提供一个接口，可以创建一系列相关或相互依赖的对象，而无需指定它们具体的类 。</li>
<li>构建器模式（Builder）：将一个复杂类的表示与其构造相分离，使得相同的构建过程能够得出不同的表示。</li>
<li>工厂方法模式（Factory Method）：定义一个创建对象的接口，但由子类决定需要实例化哪一个类。工厂方法使得子类实例化的过程推迟。 </li>
<li>原型模式（Prototype）：用原型实例指定创建对象的类型，并且通过拷贝这个原型来创建新的对象 。</li>
<li>单例模式（Singleton）：保证一个类只有一个实例，并提供一个访问它的全局访问点 </li>
</ul>
<h3 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a><strong>结构型模式</strong></h3><ul>
<li>适配器模式（Adapter）：转换接口，将一个类的接口转换成用户希望得到的另一种接口，它使原本不相容的接口可以协同工作。 </li>
<li>桥接模式（Bridge）：继承树拆分，将类的抽象部分和它的实现部分分离开来，使它们可以独立地变化 </li>
<li>组合模式（Composite）：树形目录结构，将对象组合成树型结构以表示“整体-部分”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。 </li>
<li>装饰模式（Decorator）：附加职责，动态地给一个对象添加一些额外的职责，它提供了用子类扩展功能的一个灵活的替代，比派生一个子类更加灵活。 </li>
<li>外观模式（Facade）：对外统一接口，定义一个高层接口，为子系统中的一组接口提供一个一致的外观，从而简化了该子系统的使用。 </li>
<li>享元模式（Flyweight）：提供支持大量细粒度对象共享的有效方法。 </li>
<li>代理模式（Proxy）：为其他对象提供一种代理以控制这个对象的访问。</li>
</ul>
<h3 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a><strong>行为型模式</strong></h3><ul>
<li>职责链模式（Chain of Responsibility）：职责传递，通过给多个对象处理请求的机会，减少请求的发送者与接受者之间的耦合。将接收对象链接起来，在链中传递请求，直到有一个对象处理这个请求。 </li>
<li>命令模式（Command）：日志记录，可撤销，将一个请求封装为一个对象，从而可用不同的请求对客户进行参数化，将请求排队或记录请求日志，支持可撤销的操作。 </li>
<li>解释器模式（Interpreter）：给定一种语言，定义它的文法表示，并定义一个解释器，该解释器用来根据文发表示来解释语言中的句子。 </li>
<li>迭代器模式（Iterator）：提供一个方法来顺序访问一个聚合对象中的各个元素，而不需要暴露该对象的内部表示。 </li>
<li>中介者模式（Mediator）：不可直接引用，用一个中介对象来封装一系列的对象交互，它使各对象不需要显示地相互调用，从而达到低耦合，还可以独立地改变对象间的交互。</li>
<li>备忘录模式（Memento）：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，从而可以在以后将该对象回复到原先保存的状态 </li>
<li>观察者模式（Observer）：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动更新 。</li>
<li>状态模式（State）：状态变成类，允许一个对象在其内部状态改变时时改变它的行为 。</li>
<li>策略模式（Strategy）：多方案切换，定义一系列算法，把他们一个个封装起来，并且使他们之间可以相互替换，从而让算法可以独立于使用它的用户而变化 。</li>
<li>模板方法模式（Template Method）：定义一个操作中的算法骨架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重新定义算法的某些特定步骤 。</li>
<li>访问者模式（Visitor）：表示一个作用于某对象结构中的各个元素的操作，使得在不改变各元素的类的前提下定义作用于这些元素的新操作。</li>
</ul>
]]></content>
      <categories>
        <category>软考</category>
      </categories>
      <tags>
        <tag>面向对象设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>LeanCloud</title>
    <url>/2019/10/21/LeanCloud/</url>
    <content><![CDATA[<p>添加评论<br>添加评论很简单，在主题配置文件中找到以下部分：</p>
<p>valine:<br>  enable: true<br>  appid:  # your leancloud application appid<br>  appkey:  # your leancloud application appkey<br>  notify: false # mail notifier , <a href="https://github.com/xCss/Valine/wiki" target="_blank" rel="noopener">https://github.com/xCss/Valine/wiki</a><br>  verify: false # Verification code<br>  placeholder: 聊五毛钱的天儿呗  # comment box placeholder<br>  avatar: mm # gravatar style<br>  guest_info: nick,mail,link # custom comment header<br>  pageSize: 10 # pagination size<br>去leancloud创建一个应用，将得到的appid和appkey填到这里。<br><img src="/images/createapp01.jpg" alt=""><br><img src="/images/createapp02.jpg" alt=""><br><img src="/images/createapp03.jpg" alt=""><br><img src="/images/createapp04.jpg" alt=""><br>添加统计量<br>首先在主题配置文件中找到以下部分：</p>
<p>leancloud_visitors:<br>  enable: true<br>  app_id: # your leancloud application appid<br>  app_key:  # your leancloud application appkey<br>同样，天上你在leancloud上的appid和appkey。</p>
<p>然后按照官方给的教程添加统计量。</p>
<p>教程前面划掉的部分是之前版本的做法不用管。注意一定不要漏掉一步，如果你发现你的统计量没有显示出来，那是因为你少了下面这步：<br><img src="/images/createapp05.jpg" alt=""><br>配置LeanCloud<br>在注册完成LeanCloud帐号并验证邮箱之后，我们就可以登录我们的LeanCloud帐号，进行一番配置之后拿到AppID以及AppKey这两个参数即可正常使用文章阅读量统计的功能了。</p>
<p>创建应用<br>我们新建一个应用来专门进行博客的访问统计的数据操作。首先，打开控制台，如下图所示：</p>
<p>在出现的界面点击创建应用：</p>
<p>在接下来的页面，新建的应用名称我们可以随意输入，即便是输入的不满意我们后续也是可以更改的:</p>
<p>这里为了演示的方便，我新创建一个取名为test的应用。创建完成之后我们点击新创建的应用的名字来进行该应用的参数配置：</p>
<p>在应用的数据配置界面，左侧下划线开头的都是系统预定义好的表，为了便于区分我们新建一张表来保存我们的数据。点击左侧右上角的齿轮图标，新建Class：<br>在弹出的选项中选择创建Class来新建Class用来专门保存我们博客的文章访问量等数据:<br>点击创建Class之后，理论上来说名字可以随意取名，只要你交互代码做相应的更改即可，但是为了保证我们前面对NexT主题的修改兼容，此处的新建Class名字必须为Counter:</p>
<p>由于LeanCloud升级了默认的ACL权限，如果你想避免后续因为权限的问题导致次数统计显示不正常，建议在此处选择无限制。</p>
<p>创建完成之后，左侧数据栏应该会多出一栏名为Counter的栏目，这个时候我们点击顶部的设置，切换到test应用的操作界面:<br>在弹出的界面中，选择左侧的应用Key选项，即可发现我们创建应用的AppID以及AppKey，有了它，我们就有权限能够通过主题中配置好的Javascript代码与这个应用的Counter表进行数据存取操作了:</p>
<p>复制AppID以及AppKey并在NexT主题的_config.yml文件中我们相应的位置填入即可，正确配置之后文件内容像这个样子:</p>
<p>leancloud_visitors:<br>  enable: true<br>  app_id: joaeuuc4hsqudUUwx4gIvGF6-gzGzoHsz<br>  app_key: E9UJsJpw1omCHuS22PdSpKoh<br>这个时候重新生成部署Hexo博客，应该就可以正常使用文章阅读量统计的功能了。需要特别说明的是：记录文章访问量的唯一标识符是文章的发布日期以及文章的标题，因此请确保这两个数值组合的唯一性，如果你更改了这两个数值，会造成文章阅读数值的清零重计。</p>
<p>后台管理<br>当你配置部分完成之后，初始的文章统计量显示为0，但是这个时候我们LeanCloud对应的应用的Counter表中并没有相应的记录，只是单纯的显示为0而已，当博客文章在配置好阅读量统计服务之后第一次打开时，便会自动向服务器发送数据来创建一条数据，该数据会被记录在对应的应用的Counter表中。</p>
<p>我们可以修改其中的time字段的数值来达到修改某一篇文章的访问量的目的（博客文章访问量快递提升人气的装逼利器）。双击具体的数值，修改之后回车即可保存。</p>
<p>url字段被当作唯一ID来使用，因此如果你不知道带来的后果的话请不要修改。<br>title字段显示的是博客文章的标题，用于后台管理的时候区分文章之用，没有什么实际作用。<br>其他字段皆为自动生成，具体作用请查阅LeanCloud官方文档，如果你不知道有什么作用请不要随意修改。<br>Web安全<br>因为AppID以及AppKey是暴露在外的，因此如果一些别用用心之人知道了之后用于其它目的是得不偿失的，为了确保只用于我们自己的博客，建议开启Web安全选项，这样就只能通过我们自己的域名才有权访问后台的数据了，可以进一步提升安全性。</p>
<p>选择应用的设置的安全中心选项卡:</p>
<p>在Web 安全域名中填入我们自己的博客域名，来确保数据调用的安全:</p>
<p>如果你不知道怎么填写安全域名而或者填写完成之后发现博客文章访问量显示不正常，打开浏览器调试模式，发现如下图的输出:</p>
<p>这说明你的安全域名填写错误，导致服务器拒绝了数据交互的请求，你可以更改为正确的安全域名或者你不知道如何修改请在本博文中留言或者放弃设置Web安全域名。</p>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>整理java开发默认规则</title>
    <url>/2019/10/20/haiyi-zj-gz/</url>
    <content><![CDATA[<p>1.数据清洗后，原数据字段要保留，尤其是字典<br>2.数据处理或者有日常调度的数据，必须有 更新时间字段<br>3.给其他单位协调到的数据，一定要核实，给出的数据是否符合我们的要求，包括：数据量、字段等。在民航后期协调来的数据字段项目比前期的少，量也不够，吃亏不少<br>4.建类和建方法必须加注释。<br>5.svn提交的时候必须要加注释。<br>6.页面新增数据的时候注意input和textarea长度需要根据数据库中字段进行长度校验。<br>7.注意代码的缩进，别太参差不齐。<br>8.建表要加注释，表注释要非常清楚，而且要有基本索引。<br>9.对象的使用注意非空判断。<br>10.数据汇集的时候不要把字段丢掉，比如民航阿里推送的数据明明有手机号，可以汇总到人头总表，却没有手机号了<br>11.服务器一定要利用用户提供的，别瞎倒腾，最后如果服务器出了问题或者断电等，不好解释，而且工作量还会大很多<br>12.数据库服务器一定要跟 其他应用服务器分开，不然，出现让人家重启一个应用服务， 结果数据库直接宕机的问题<br>13. 数据一定要清洗去重再入库，如果清洗规则变了 ，历史的也要重新按照新规则清洗<br>14.不确定的事情不要贸然评估并给用户承诺（经典答复：回去落实一下，再汇报）<br>15.重要数据清洗前，一定要进行备份<br>16.对生产库中的数据进行操作，一定不要用truncate<br>17.录屏的时候，把电脑任务栏清理下，不要全国建模视频上，还有uep的图标<br>18.专业人干专业事，稍微勉强的，尽量别接，抛出去，总比做差了，用户会认为我们不专业。–民航剪辑事件<br>19.数据清洗的时候，如果有字典翻译不过来的时候，应该反查下都什么字典没能翻译，比如KOS，西哈努克，东南亚关键地区竟然没翻译<br>20.项目经理或者小组负责人不需要做具体任务，要腾出充足的时间思考，分析用户意图，尽量让小组成员能轻松准确无返工的完成工作<br>21.紧急的事情紧急做法（只要达到目标，可以适当走捷径），不要妄图在几天的紧张氛围内把每一个细节都处理到位，这样会让用户等待。<br>22.不要妄图用关系数据库实现一亿以上数表关联，要尽量的加更多的条件过滤数据。 聚合表可以适当有，但是像“频繁前往东南亚和云南地区”这种，千万不要妄图先得到全轨迹中频繁前往的，再组合得到红色人员符合频繁的、橙色人员符合频繁的；而是应该分开用更多的条件过滤出数据，这样会更高效 。—这回被用户带沟里去了<br>23.列表显示内容时，如果内容是固定的，单元格的宽度需要写死，并且居中，如果内容长度不一，则左对齐，超出内容用点点点代替<br>24.列表展示内容需要与Excel导出一致，即：列表上是个代码，导出也要是个代码<br>25.外网开发，内网部署，是原则。拍错应该看日志，而不是用uep调试。我们不应该太依赖内网，更不应该太依赖uep代码调试<br>26.捕获异常却不处理异常，是很愚蠢的，纯属于自己给自己挖坑<br>27.structs中action中的 业务方法名字，一律不准用get开头，否则会被调用两次，浪费服务器资源。</p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo NexT主题中添加网页音乐播放器功能</title>
    <url>/2019/10/18/music-player/</url>
    <content><![CDATA[<p>Hexo NexT主题中添加网页音乐播放器功能<br> Posted on 2018-05-26 |  In GitBlog |  Visitors: 4666<br>为博客添加网页音乐播放器功能</p>
<p>download<br>点击访问Aplayer源码：GitHub Aplayer。下载到本地，解压后将dist文件夹复制到themes\next\source文件夹下。</p>
<p>music.js<br>新建themes\next\source\dist\music.js文件，添加内容：</p>
<p>const ap = new APlayer({<br>    container: document.getElementById(‘aplayer’),<br>    fixed: true,<br>    autoplay: false,<br>    audio: [<br>      {<br>        name: “PDD洪荒之力”,<br>        artist: ‘徐梦圆’,<br>        url: ‘<a href="http://up.mcyt.net/?down/39868.mp3&#39;" target="_blank" rel="noopener">http://up.mcyt.net/?down/39868.mp3&#39;</a>,<br>        cover: ‘<a href="http://oeff2vktt.bkt.clouddn.com/image/84.jpg&#39;" target="_blank" rel="noopener">http://oeff2vktt.bkt.clouddn.com/image/84.jpg&#39;</a>,<br>      },<br>      {<br>        name: ‘9420’,<br>        artist: ‘麦小兜’,<br>        url: ‘<a href="http://up.mcyt.net/?down/45967.mp3&#39;" target="_blank" rel="noopener">http://up.mcyt.net/?down/45967.mp3&#39;</a>,<br>        cover: ‘<a href="http://oeff2vktt.bkt.clouddn.com/image/8.jpg&#39;" target="_blank" rel="noopener">http://oeff2vktt.bkt.clouddn.com/image/8.jpg&#39;</a>,<br>      },<br>      {<br>        name: ‘风筝误’,<br>        artist: ‘刘珂矣’,<br>        url: ‘<a href="http://up.mcyt.net/?down/46644.mp3&#39;" target="_blank" rel="noopener">http://up.mcyt.net/?down/46644.mp3&#39;</a>,<br>        cover: ‘<a href="http://oeff2vktt.bkt.clouddn.com/image/96.jpg&#39;" target="_blank" rel="noopener">http://oeff2vktt.bkt.clouddn.com/image/96.jpg&#39;</a>,<br>      }<br>    ]<br>});<br>源码中对应的参数解释，这边都有： Aplayer 中文文档</p>
<p>audio对应的便是音频文件，所以音乐播放器需要播放的音乐是需要自己进行相关信息（如歌曲链接、歌词、封面等）的配置。这里放一个mp3音乐外链网站：<a href="http://up.mcyt.net/" target="_blank" rel="noopener">http://up.mcyt.net/</a> ，搜索对应的音乐，然后复制url和右击封面图片链接粘贴到对应的位置上就行了。</p>
<p>注：由于该外链网站没有歌词链接，我这边没有进行配置，所以播放器在播放音乐时点击歌词是没有显示的。</p>
<p>_layout.swig<br>打开themes\next\layout_layout.swig文件，将</p>
<link rel="stylesheet" href="/dist/APlayer.min.css">
<div id="aplayer"></div>
<script type="text/javascript" src="/dist/APlayer.min.js"></script>
<script type="text/javascript" src="/dist/music.js"></script>
添加到<body itemscope ...>后面就行，即在<body></body>里面。

<p>重新生成，访问页面，就能看到左下角的音乐播放器了。</p>
]]></content>
      <tags>
        <tag>hexo next</tag>
      </tags>
  </entry>
</search>
